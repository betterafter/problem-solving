<span style="font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif">

## programmers 12900 - 2 * N 타일링


### 문제 
<b>https://programmers.co.kr/learn/courses/30/lessons/12900</b>


<br/><br/><br/><br/><br/><br/>


### 문제 풀이<b>
이미 여러 코딩 테스트나 대회에서 다양한 형태로 변형되어 출제된 다이나믹 프로그래밍(dynamic programming)의 대표적인 문제이다.

문제에 의하면 만들 수 있는 파츠는 세로 1개짜리(|)와 가로 2개짜리 (=)가 있다. 이것을 적절히 조합하면 되는 문제이다. n = 4일 때까지 하나씩 구해보자.
<br/>
n = 1
[ | ] (세로 1개짜리 1개)
<br/>
n = 2
[ || ] (세로 1개짜리 2개),  [ = ] (가로 2개짜리 1개)
<br/>
n = 3
[ ||| ], [ =| ],  [ |= ] 로 3가지 모양이 나올 수 있다. 

여기서부터 봐야할 것은 
[ ||| ] ---> [ || ] (n = 2일 때 첫번째 모양) + [ | ]
[ =| ] ---> [ = ] (n = 2일 때 두번째 모양) + [ | ]
[ |= ] ---> [ | ] (n = 1일 때 첫번째 모양) +  [ = ]
이라는 점이다.
<br/>
n = 4
[ ||= ], [ == ], [ |||| ], [ =|| ], [ |=| ]

여기서는
[ ||= ] ---> [ || ] + [ = ]
[ == ] ---> [ = ] + [ = ]
[ |||| ] ---> [ ||| ] + [ | ]
[ =|| ] ---> [ =| ] + [ | ]
[ |=| ] ---> [ |= ] + [ | ] 

이 쯤 되면 더 볼 필요도 없다. n번째의 모양은 n-2번째 모양에 [ = ]를 붙이는 것과 n-1번째 모양에 [ | ]를 붙이는 것들의 집합이 된다. 따라서 n번째 모양의 개수는 n-2번째 모양의 개수 + n-1번째 모양의 개수가 되는 것이다. n번째의 개수를 dp[n]에 저장한다면 아래와 같은 점화식을 만들 수 있다.
```
dp[n] = dp[n - 2] + dp[n - 1]
```

다만 n이 60000 이하의 자연수라면 값이 매우 커질 위험이 있다. 대신 문제의 조건이 1000000007를 나눈 나머지가 답이 된다고 했으므로 아래의 코드와 같이 나오게 된다.

```java
#include <string>
#include <vector>

using namespace std;

int DIV = 1000000007;
int dp[60001];

int solution(int n) {
    int answer = 0;

    dp[1] = 1; dp[2] = 2; dp[3] = 3;
    for(int i = 4; i <= n; i++){
        dp[i] = (dp[i - 1] + dp[i - 2]) % DIV; 
    }

    answer = dp[n] % DIV;
    return answer;
}
```

결국 문제의 점화식을 제대로 세울 수 있는지에 따라 갈리는 문제가 되겠다.
</b>
</span>
