<span style="font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif">

## programmers 42860 - 조이스틱


### 문제 
<b>https://programmers.co.kr/learn/courses/30/lessons/42860</b>


<br/><br/><br/><br/><br/><br/>


### 문제 풀이<b>
문제 자체는 쉬운데, 문제가 오류가 있어서 추가 설명을 하자면, 아래의 조건에 추가해야할 내용이 있다.

◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
▶ - 커서를 오른쪽으로 이동

여기서 왼쪽으로 계속 이동하면 마지막 문자에 커서가 이동하고, 오른쪽으로 이동할 경우에는 맨 왼쪽으로 이동한다고 명시되어 있지 않은데, 오른쪽으로 계속 이동해도 왼쪽으로 이동할 때와 마찬가지로 작동한다.

이 문제가 Greedy에 분류된 이유는 아래의 조건에서 확인할 수 있다.

▲ - 다음 알파벳
▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)

사실 상 그냥 문자부터 바꿔버리면 되는 것이나 마찬가지이므로 Greedy하게 풀 수 있는 것. 문자를 전부 적절한 문자로 변환하는 알고리즘은 어렵지 않다. 사실 변환도 할 필요 없이 그냥 카운팅만 해주면 된다.
```java
for(int i = 0; i < name.length(); i++){
    cnt[i] = min(name[i] - 'A', 90 - name[i] + 1);
    answer += cnt[i];
    if(name[i] != 'A') idx.push_back(i);
}
```
if문은 거리 계산을 위한 것이므로 일단 제외한다. 이동 연산은 아래와 같은 아이디어로 구현했다.

 오른쪽 갔다가 다시 돌아와서 왼쪽 쭉 누르는 패턴 반복
     AAABABABAA라는 것이 있으면
     1. AAABABAB (왼쪽 커서만 누르기)
     2. AAAB (오른쪽 커서 누르기) -> 다시 처음으로 돌아간 후 -> AABAB (왼쪽 커서 누르기)
     3. AAABAB (오른쪽 커서 누르기) -> 다시 처음으로 돌아간 후 -> AAB (왼쪽 커서 누르기)
     4. AAABABAB (오른쪽 커서만 누르면 끝)

오른쪽 커서만 쭉 누를 것인지, 왼쪽 커서만 쭉 누를 것인지, 오른쪽과 왼쪽 커서를 적절히 조합할 것인지를 결정하는 것인데, 그냥 모든 경우의 수를 다 체크해보고 가장 적은 키 만으로 이동할 수 있는 것을 뽑으면 된다.
```java
for(int i = 0; i < idx.size(); i++){
    len = 0;
    // 오른쪽 커서 누르기
    for(int p = 0; p < idx[i]; p++){
        len++;
    }
    // 다시 뒤로 이동
    len *= 2;
    // 왼쪽 커서를 누를 필요가 있다면 왼쪽 커서 누르기. AABBAA 같은 경우에서 AABB까지 누르면 왼쪽 커서는 누를 필요가 없으니까.
    if(idx.size() - 1 >= i + 1){
        for(int q = idx[i + 1]; q < name.length(); q++){
            len++;
        }
    }
    dist = min(dist, len);
}
```
</b>
</span>
