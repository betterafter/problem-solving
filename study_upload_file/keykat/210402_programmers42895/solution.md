<span style="font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif">

## programmers 42895 - N으로 표현


### 문제 
<b>https://programmers.co.kr/learn/courses/30/lessons/42895</b>


<br/><br/><br/><br/><br/><br/>


### 문제 풀이<b>

<br/><br/><br/>

#### 본인의 풀이 
본인이 푼 방법은 매우 비효율적인 코드라고 생각하여 다른 사람의 코드를 좀 더 자세하게 설명하도록 하겠다. 일단 본인이 푼 방법은 아래와 같다.

0. 5부터 55555555까지 맵에 넣어준다. 맵에는 map<만들어지는 수, 이 수를 만들기 위해 필요한 5의 개수>의 값으로 넣어준다. 즉, 현재 맵에는 
<5, 1>, <55, 2>, <555, 3>, <5555, 4>, ... <55555555, 8>이 들어가게 된다.
<br/>
1. 5, 55, 555, 5555, ... , 55555555 각각을 5, 55, 555, 5555, ... , 55555555로 사칙연산을 한다. 즉,

- 1-1
5 + 5, 5 + 55, 5 + 555, ... 5 + 55555555
5 - 5, 5 - 55, 5 - 555, ... 5 - 55555555
5 * 5, 5 * 55, 5 * 555, ... 5 * 55555555
5 / 5, 5 / 55, 5 / 555, ... 5 / 55555555
- 1-2
55 + 5, 55 + 55, 55 + 555, ... 55 + 55555555
55 - 5, 55 - 55, 55 - 555, ... 55 - 55555555
55 * 5, 55 * 55, 55 * 555, ... 55 * 55555555
55 / 5, 55 / 55, 55 / 555, ... 55 / 55555555
...
- 1-8
55555555 + 5, 55555555 + 55, 55555555 + 555, ... 55555555 + 55555555
55555555 - 5, 55555555 - 55, 55555555 - 555, ... 55555555 - 55555555
55555555 * 5, 55555555 * 55, 55555555 * 555, ... 55555555 * 55555555
55555555 / 5, 55555555 / 55, 55555555 / 555, ... 55555555 / 55555555

와 같이 모든 시작 가능한 경우의 수를 map에 넣어준다. 

2. 맵에 있는 만들어지는 수를 하나씩 뽑아와서 맵에 있는 모든 수와의 사칙연산을 다시 해준다. 이렇게하면 5와 사칙연산만으로 만들 수 있는 모든 수를 구할 수 있게 된다. 
<br/>
3. 이 때, 알고리즘 상에서는 1-1을 먼저 실행한 후, 1-1에서 생긴 결과를 맵에 넣고, 그 결과에 대해서 다시 맵에 있는 모든 수와의 사칙연산을 각각 실행한 후에 1-2로 넘어가는 방식으로 하였다. 이렇게 해도 어차피 맵에서 이미 만들어진 수는 업데이트하면 되고 새로 만들어진 수는 어차피 다시 돌리게 되니까 빠짐 없이 돌릴 수 있다.

핵심 알고리즘은 아래와 같다. 참고로 두개의 코드는 while문 하나에 들어간 것인데, 일부러 나눠놨다.

```c++
  while(!q.empty()){
        int curr = q.front(); q.pop();
        for(int i = 0; i < 8; i++){
            // 길이가 8 이하이면서
            int length = dp[curr] + i + 1;
            if(length <= 8){
                int ccalc[4] = { curr + nn[i], curr - nn[i], curr * nn[i], curr / nn[i] };
                for(int ii = 0; ii < 4; ii++){
                    if(dp.find(ccalc[ii]) == dp.end() || (dp.find(ccalc[ii]) != dp.end() && dp[ccalc[ii]] > length) ){
                        dp[ccalc[ii]] = length; q.push(ccalc[ii]);
                    }
                }
            }
        }
```
첫번째에서 5와 5, 55, 555, ... 55555555와의 사칙연산으로 만들 수 있는 모든 스타팅 넘버를 만들고, (위에서 1-1) 이것을 전부 맵에 넣어준다. 여기서 만들어진 수는 queue에도 넣어서 bfs와 같은 방식으로 돌려준다.
```c++

        int calc[4] = { 0, };
        map<int, int> :: iterator iter;
        for(iter = dp.begin(); iter != dp.end(); iter++){
            int key = (int)(iter -> first);
            int length = (int)(iter -> second) + dp[curr];
            if(length <= 8){
                calc[0] = curr + key;
                calc[1] = curr - key;
                calc[2] = curr * key;
                if(key != 0) calc[3] = curr / key;
                for(int ii = 0; ii < 4; ii++){
                    if(dp.find(calc[ii]) == dp.end() || (dp.find(calc[ii]) != dp.end() && dp[calc[ii]] > length) ){
                        if(ii == 3 && key == 0) continue;
                        dp[calc[ii]] = length; q.push(calc[ii]);
                    }
                }
            }
        }
    }
```
이제 맵에 넣은 모든 수를 처음부터 빼와서 맵에 있는 모든 수와의 사칙연산으로 만들 수 있는 수를 구하고, 여기서 만들어진 수도 맵에 또 넣어준다. 이 때 겹치는 것은 횟수가 낮은 걸로 업데이트만 해주면 된다. 마찬가지로 만들어진 수를 queue에 넣어 bfs로 풀 수 있게 한다. 굳이 bfs를 쓰지 않아도 그냥 맵에서 하나씩 꺼내서 돌려도 상관은 없다. (어차피 그게 그거)


<br/><br/><br/>
#### 다른 사람의 풀이
다만 위의 방법으로 풀면 당연하지만 map을 탐색하는 데에도 시간이 너무 오래걸리고, bfs를 돌려야하기 때문에 여기서도 시간이 좀 걸리게 된다. 실제로 문제 풀이가 통과는 되지만, 심할 경우 한 문제에 2초 이상 걸리는 경우도 있다. 이 때 다른 사람이 푼 아래의 풀이가 매우 인상적이라 가져왔다.

```c++
int solution(int N, int number) {
    int answer = -1;
    unordered_set<int> s[8];
    
    int sum = 0;
    for(int i = 0 ; i < 8 ; i++){
        sum = sum * 10 + N;
        s[i].insert(sum);
    }

    for(int i = 1 ; i < 8 ; i++){
        for(int j = 0 ; j < i ; j++){
            for(auto& op1 : s[j]){
                for(auto& op2 : s[i-j-1]){
                    s[i].insert(op1 + op2);
                    s[i].insert(op1 - op2);
                    s[i].insert(op1 * op2);
                    if(op2 != 0) s[i].insert(op1 / op2);
                }
            }
        }
        if(s[i].count(number)){
            answer = i + 1;
            break;
        }
    }
    return answer;
}
```

실로 아름다운 풀이다. 풀이는 아래와 같다.
1. set 자료구조를 8개를 만들어주고, 각 인덱스에 만드는 데에 사용한 횟수가 동일한 수를 넣어주는 것이다. 가령 5를 만드는데 사용한 5의 개수는 1개이므로 s[1]에 넣어주고, 10을 만드는데 5 + 5, 즉 2개로 만들 수 있으므로 s[2]에 넣어주고, 12를 만드는데에 (55 + 5) / 5로 만들 수 있으므로 s[4]에 넣어주는 식이다. set을 쓰는 이유는 중복되는 숫자를 제거하기 위함으로 보인다.
2. 일단 5부터 55555555까지 s[1] ~ s[8]에 각각 해당하는 구간에 넣어주고, s 배열을 돌면서 조합을 만들어본다. 가령 s[1]과 s[1]을 조합하면 5를 사용한 횟수가 1개인 숫자들끼리 조합해서 s[2], 즉 5를 사용한 횟수가 2개인 숫자를 만들 수 있게 된다. 이렇게 s[1]~s[8]과 다시 s[1]~s[8]을 조합해서 새로운 숫자들을 다시 set 배열 안에 넣고 돌리는 방식이다. 다만 s[8]과 s[1]~s[8]은 필요 횟수가 8을 넘어가기 때문에 의미가 없는 것처럼, 조합에서 필요한 개수가 8이 넘어가지 않도록 조합을 짜기만 하면 된다.
 
</b>
</span>
