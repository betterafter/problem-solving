<span style="font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif">

## programmers 42584 - 주식 가격


### 문제 
<b>https://programmers.co.kr/learn/courses/30/lessons/42584</b>


<br/><br/><br/><br/><br/><br/>
### 문제 풀이<b>
<br/><br/><br/>
완전 탐색으로 풀었다가 망해서 큐로 풀었다. 자세히 보니 괄호 유형의 문제와 매우 비슷하다. 스택 전체를 하나씩 탐색하면서, 스택의 맨 위에 있는 수가 현재 탐색 중인 수보다 작으면 그냥 스택에 넣고, 현재 탐색 중인 수보다 크면 빼고 각각의 시간을 기록하는 것이다. 예를 들어,

1   2   3   2   3

1. 1을 스택에 넣은 시점의 시간과 함께 넣는다.
2. 2는 스택의 탑인 1보다 크므로 스택에 그냥 넣는다.
3. 3은 2보다 크므로 스택에 넣는다.
4. 2는 3보다 작으므로 빼고 뺀 시간을 기록해주고 스택에 넣는다.
5. 3은 2보다 크므로 스택에 넣는다.
6. 스택에 남아있는 모든 것을 빼면서 시간을 기록해준다.

위의 과정을 그림으로 표현하면 아래와 같다.
일단 스택에 넣을 데이터 형태는 pair<주식 가격, 시간>이라고 하자.

1. 1초 경과
<1, 1> ------ 스택에 아무것도 없으니 그냥 넣는다.

기록 : 
[1초에 넣은 것 : ] 


<br/><br/>

2. 2초 경과
<2, 2> ------ 스택의 탑인 1보다 2가 크므로 스택에 넣는다. 
<1, 1>

기록 : 
[1초에 넣은 것 : ] 
[2초에 넣은 것 : ] 


<br/><br/>

3. 3초 경과 
<3, 3> ------ 스택의 탑인 2보다 3이 크므로 스택에 넣는다. 
<2, 2> 
<1, 1>

기록 : 
[1초에 넣은 것 : ] 
[2초에 넣은 것 : ] 
[3초에 넣은 것 : ] 

<br/><br/>

4. 4초 경과
<2, 4> ------ 스택의 탑인 3보다 2가 작으므로 스택에서 3을 빼고 넣는다.
//<3, 3> ---- 2보다 크므로 스택에서 빼준다. 3초에 넣었고 현재 4초이므로 4 - 3 = 1
<2, 2> ---- 2와 같으므로 뺄 필요 없다.
<1, 1> ---- 2보다 작으므로 뺄 필요 없다.

기록 : 
[1초에 넣은 것 : ] 
[2초에 넣은 것 : ] 
[3초에 넣은 것 : 1초] 
[4초에 넣은 것 : ]  

<br/><br/>

5. 5초 경과 끝
<3, 5> ---- 2보다 크므로 그냥 스택에 넣는다.
<2, 3> 
<2, 2> 
<1, 1> 

기록 : 
[1초에 넣은 것 : ] 
[2초에 넣은 것 : ] 
[3초에 넣은 것 : 1초] 
[4초에 넣은 것 : ]  
[5초에 넣은 것 : ]  

<br/><br/>

6. 스택에서 전부 빼면서 시간 기록. 끝난 시간은 5초
<3, 5> ---- 5 - 5 = 0초로 기록
<2, 3> ---- 5 - 3 = 2초로 기록
<2, 2> ---- 5 - 2 = 3초로 기록
<1, 1> ---- 5 - 1 = 4초로 기록

기록 : 
[1초에 넣은 것 : 4초] 
[2초에 넣은 것 : 3초] 
[3초에 넣은 것 : 1초] 
[4초에 넣은 것 : 2초]  
[5초에 넣은 것 : 0초]


핵심 알고리즘은 다음과 같다.

```c++
    // 처음부터 끝까지 주식가격을 탐색한다.
  for(int i = 0; i < prices.size(); i++){
      // 탐색 중인 시점의 가격
        int price = prices[i];

        // 현재 탐색 중인 시점의 주식 가격과 스택에 있는 것들의 가격 비교
        while(!s.empty()){
            // 스택에 들어있는 주식 가격이 더 크면 빼고 시간 기록
            if(s.top().first > price){
                res[s.top().second] = i - s.top().second; 
                s.pop();
            }
            // 아니면 스택 탐색 중지. 어차피 뒤에 있는 거는 탑보다 다 작은 것들이니까.
            else break;
        }
        // 현재 꺼는 스택에 넣어줌.
        s.push(make_pair(price, i));
    }
```
```c++
// 스택에 남아 있는 것들 전부 꺼내면서 시간 기록
while(!s.empty()){
    res[s.top().second] = prices.size() - s.top().second - 1;
    s.pop();
}
```

참고로 for문 쌩으로 돌리면 O(nlogn) 타임 쯤 나올 거 같은데 통과 안되더라. 정확성은 몰라도 효율성에서 다 걸린다.

<br/><br/><br/>

</b>
</span>
