<span style="font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif">

## programmers 42883 - 큰 수 만들기


### 문제 
<b>https://programmers.co.kr/learn/courses/30/lessons/42883</b>


<br/><br/><br/><br/><br/><br/>


### 문제 풀이<b>
쓰다 보니 설명이 무척 길어졌는데, 괜히 주절주절 말이 많은 것 뿐 매우 쉬운 문제이다.

dfs인 줄 알고 풀었는데 이상하게 통과가 안 되길래 다른 사람들이 질문 올린 거 보고 이상함을 깨달음. 요컨데 문제 잘 못 보고 망함. 처음부터 다시 풀었음.
조건이 "number는 1자리 이상, 1,000,000자리 이하인 숫자입니다." 이였는데 1,000,000 이하의 수가 아니라 1,000,000 "자리"의 수였다. 1,000,000 이하의 수면 당연히 dfs로 풀면 끝인데 (심지어 dfs로 푼 거 제출했더니 시간 초과 아니면 통과기는 했다.) 일단 자리수가 어마어마하므로 당연하게도 메모리 초과 및 시간 초과가 걸릴 만 하다.

참고로 이 문제를 주어진 수 안에 있는 숫자를 이리저리 조합해서 큰 수를 만드는 것으로 착각하는 사람들이 많던데, 그것도 아니다. 순서는 그대로 두고 큰 수를 만드는 것이다.

생각해보면 어차피 주어진 수 중에서 몇개 지워서 가장 큰 수를 만드는 건데, 가장 큰 수의 조건은 맨 앞의 수가 최대한 크면 된다는 것이다. 그럼 앞에서부터 탐색하면서 특정 조건에 의해 제거하거나 붙여버리면 될 것이다. 예를 들어보자.

4177252841 (4개 제거)

4개를 제거한다면 만들어지는 수는 당연히 6자리일 것이다. 따라서 앞에서부터 탐색하려면 6자리는 확보해야한다는 것을 생각하면서 풀어야한다. 가령 6자리 수를 
[1] [2] [3] [4] [5] [6] 로 공간을 잡고 생각해보자.

<br/><br/><br/>
1. 
[1]에는 몇부터 몇까지 들어갈 수 있을까? [2], [3], [4], [5], [6]에도 수가 필수적으로 들어가야 하니까 최소한 4177252841 이 수에서 
[1] "[2,3,4,5,6]"
41772 "52841" 
이거는 최소한으로 남겨야한다. 따라서 [1]에는 4, 1, 7, 7, 2 중에 가장 큰 수를 넣으면 된다. 그럼 첫번째 7과 두번째 7중 어떤게 들어가면 좋을까? 당연히 첫번째 7이다. 2211에서 2개를 제거하는 경우를 생각해보자. 첫번째 2를 선택하면 다음 수는 자연스럽게 2를 선택하면 되지만, 두번째 2를 먼저 선택해버리면 첫번째 2는 자연스럽게 잉여가 되면서 21밖에 못 만들게 된다. 따라서 같은 수가 있다면 무조건 빠른 인덱스를 선택해준다.

1번 결과
[1] [2] [3] [4] [5] [6]
[7] [?] [?] [?] [?] [?]
<br/><br/><Br/>
2.
이제 첫번째 7을 골랐으므로 7252841 중에서 골라야한다. 6자리 중에 1자리는 확보했으니 이제 최소 5자리를 확보할 수만 남기고 골라줘야한다. 요컨데 
[2] "[3,4,5,6]"
725 "2841"
로 잘라서 7과 2 중에 선택하면 된다.

2번 결과
[1] [2] [3] [4] [5] [6]
[7] [7] [?] [?] [?] [?]
<br/><br/><Br/>
3.
이제 위의 과정 반복이다. 뒤의 3자리 확보하고 [3]에 들어갈 것은 2, 5, 2 중에 고른다.
 
3번 결과
[1] [2] [3] [4] [5] [6]
[7] [7] [5] [?] [?] [?]
<br/><br/><Br/>
4.
뒤의 2자리 확보하고 2, 8중에 고른다.

4번 결과
[1] [2] [3] [4] [5] [6]
[7] [7] [5] [8] [?] [?]
<br/><br/><Br/>
5.
반복 돌리면 알아서 채워지긴 한다.

3번 결과
[1] [2] [3] [4] [5] [6]
[7] [7] [5] [8] [4] [1]

<br/><br/><br/><br/><br/><br/> 
### 알고리즘

설명이 쓸 데 없이 길긴 한데, 잘 생각하면 매우 쉬운 문제. 그래서 알고리즘도 매우 짧다.

아래의 코드에서 중요한 게 있는데, 

4177252841 (4개 제거)

위의 경우 첫번째 단계에서
41772 / 52841로 잘라주고 첫번째 7 (index 번호 : 2번)을 선택한다고 했다. 이 경우 다음에 탐색할 첫번째 인덱스는 3번부터 탐색하면 되는 것이다.
(2번째에는 7,2,5를 탐색하게 되니까)
prev는 이 탐색 시작할 인덱스를 담을 변수인데, 왜 -1에서 인덱스 탐색을 시작할까?

prev = 0이면 for(int i = prev + 1; i < next; i++) 이 부분에서 1, 2, 3, ..., 즉 0번 인덱스 탐색을 건너 뛰게 된다. 그럼 prev = 0 시작에 i = prev로 준다면?
321을 생각해봐라. 가장 큰 수의 인덱스가 0이니까 for문이 무한으로 반복될 것이다. 그래서 prev = -1에 i = prev + 1이다.

```c++
int prev = -1;
int next = k + 1;

// 각 자리 수를 탐색
while(next <= number.length()){
    int MAX = 0;
    
    // 탐색 시작할 인덱스부터 자리 확보된 인덱스 전까지 탐색하면서 가장 큰거 골라주기.
    for(int i = prev + 1; i < next; i++){
        // 같은거 일때도 앞의 인덱스로 선택
        if(MAX < number[i]){
            MAX = number[i]; prev = i;
        }
    }
    k--; answer += number[prev]; next++;
}
```

</b>
</span>
